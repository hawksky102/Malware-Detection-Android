package com.app.phonecleaner.Service;

import android.annotation.SuppressLint;
import android.app.AlarmManager;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.app.usage.NetworkStats;
import android.app.usage.NetworkStatsManager;
import android.content.*;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.os.*;
import android.util.Log;
import android.widget.Toast;

import androidx.annotation.NonNull;

import com.app.phonecleaner.Notification.NotificationHelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class BackgroundService extends Service {

    public Context context = this;
    public Handler handler = null;
    public static Runnable runnable = null;
    ArrayList<String> packageName;
    ArrayList<String> applicationName;
    ArrayList<String> rxData;
    ArrayList<Long> rxSimple;
    ArrayList<String> txData;
    ArrayList<Long> txSimple;
    ArrayList<Bitmap> applicationIcon;
    String[] applicationNameArr;
    Bitmap[] applucationIconArr;
    String[] applicationPackageArr;
    String[] applicationRxArr;
    String[] applicationTxArr;
    SharedPreferences sharedPreferences;
    int timer = 10000;
    int datalimit = 5;

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        Toast.makeText(this, "Service created!", Toast.LENGTH_LONG).show();
        sharedPreferences = getSharedPreferences("default_settings", Context.MODE_PRIVATE);
        String time_get = sharedPreferences.getString("timing", null);
        String data_get = sharedPreferences.getString("data", null);
        if (time_get != null && data_get != null) {
            timer = Integer.valueOf(time_get) * 60000;
            datalimit = Integer.valueOf(data_get);
        }
        doProcessing();
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        doProcessing();
        //else stopMyService();
        return START_STICKY;
    }
    @Override
    public void onTaskRemoved(Intent rootIntent){
        Intent restartServiceIntent = new Intent(getApplicationContext(), this.getClass());
        restartServiceIntent.setPackage(getPackageName());

        PendingIntent restartServicePendingIntent = PendingIntent.getService(getApplicationContext(), 1, restartServiceIntent, PendingIntent.FLAG_ONE_SHOT);
        AlarmManager alarmService = (AlarmManager) getApplicationContext().getSystemService(Context.ALARM_SERVICE);
        alarmService.set(
                AlarmManager.ELAPSED_REALTIME,
                SystemClock.elapsedRealtime() + 1000,
                restartServicePendingIntent);

        super.onTaskRemoved(rootIntent);
    }
    @Override
    public void onDestroy() {
        /* IF YOU WANT THIS SERVICE KILLED WITH THE APP THEN UNCOMMENT THE FOLLOWING LINE */
        //handler.removeCallbacks(runnable);
        Toast.makeText(this, "Service stopped", Toast.LENGTH_LONG).show();
    }

    @Override
    public void onStart(Intent intent, int startid) {
        Toast.makeText(this, "Service started by user.", Toast.LENGTH_LONG).show();
    }

    public void doProcessing(){
        Log.e("Timers",String.valueOf(timer));
        handler = new Handler();
        runnable = new Runnable() {
            public void run() {

                new ServerConnection().execute();
                handler.postDelayed(runnable, timer);
            }
        };

        handler.postDelayed(runnable, timer);
    }

    public void getNetStats(@NonNull Context context, long startTime, long endTime, int netType, int uid, String packagename, String applicationname, Drawable
            applicationicon) {
        long netDataReceive = 0;
        long netDataSend = 0;
        String subId = null;
        @SuppressLint("WrongConstant") NetworkStatsManager manager = (NetworkStatsManager) context.getApplicationContext().
                getSystemService(Context.NETWORK_STATS_SERVICE);

        if (manager == null) {
        }
        NetworkStats networkStats = null;
        // NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        try {
            networkStats = manager.queryDetailsForUid(netType, subId, startTime, endTime, uid);
        } catch (Exception e) {
            e.printStackTrace();
        }
        Log.d("Startdate: ", "" + startTime + "   ");
        Log.d("Enddate: ", "" + endTime + "    ");
        long tx = 0L;
        long rx = 0L;
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        while (networkStats != null && networkStats.hasNextBucket()) {
            networkStats.getNextBucket(bucket);
            tx += bucket.getTxBytes();
            rx += bucket.getRxBytes();
            // Log.d("tag1","StartTime: "+bucket.getStartTimeStamp());
            // Log.d("tag1","EndTime: "+bucket.getEndTimeStamp());
        }
        if (tx != 0 || rx != 0) {
            packageName.add(packagename);
            applicationName.add(applicationname);
            rxData.add(humanReadableByteCount(rx));
            txData.add(humanReadableByteCount(tx));
            applicationIcon.add(drawableToBitmap(applicationicon));
            rxSimple.add(rx);
            txSimple.add(tx);


        }


    }

    public static String humanReadableByteCount(long bytes) {
        int unit = 1024;
        if (bytes < unit) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = "KMGTPE".charAt(exp - 1) + "";
        return String.format(Locale.getDefault(), "%.1f %sB", bytes / Math.pow(unit, exp), pre);
    }

    public static Bitmap drawableToBitmap(Drawable drawable) {
        Bitmap bitmap = null;

        if (drawable instanceof BitmapDrawable) {
            BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
            if (bitmapDrawable.getBitmap() != null) {
                return bitmapDrawable.getBitmap();
            }
        }

        if (drawable.getIntrinsicWidth() <= 0 || drawable.getIntrinsicHeight() <= 0) {
            bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); // Single color bitmap will be created of 1x1 pixel
        } else {
            bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
        }

        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);
        return bitmap;
    }

    public int findMaximumUsage(ArrayList<Long> allData) {
        Integer maxIdx = 0;
        try {
            Long maxVal = Collections.max(allData);
            maxIdx = allData.indexOf(maxVal);
        } catch (Exception ex) {

        }
        return maxIdx;
    }

    public class ServerConnection extends AsyncTask<Void, String, Void> {

        @Override
        protected Void doInBackground(Void... params) {
                            packageName = new ArrayList<String>();
                applicationName = new ArrayList<String>();
                rxData = new ArrayList<String>();
                txData = new ArrayList<String>();
                txSimple = new ArrayList<Long>();
                rxSimple = new ArrayList<Long>();
                sharedPreferences = getSharedPreferences("default_settings", Context.MODE_PRIVATE);
                String time_get = sharedPreferences.getString("timing", null);
                String data_get = sharedPreferences.getString("data", null);
                if (time_get != null && data_get != null) {
                    timer = Integer.valueOf(time_get) * 60000;
                    datalimit = Integer.valueOf(data_get);
                }

                applicationIcon = new ArrayList<Bitmap>();

            Calendar cal1 = Calendar.getInstance();
            cal1.add(Calendar.DATE, 1);
            Date end = cal1.getTime();
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, -1);
                long start = cal.getTime().getTime();


                PackageManager packageManager = getPackageManager();
                Intent intent = new Intent(Intent.ACTION_MAIN, null);
                intent.addCategory(Intent.CATEGORY_LAUNCHER);
                List<ResolveInfo> package_name = packageManager.queryIntentActivities(intent, 0);

                for (ResolveInfo resolveInfo : package_name) {
                    int uid = 0;
                    try {
                        uid = getPackageManager().getApplicationInfo(String.valueOf(resolveInfo.activityInfo.packageName), 0).uid;
                    } catch (PackageManager.NameNotFoundException e) {
                        e.printStackTrace();
                    }
                    Log.e("--------", "---------------------------------");
                    getNetStats(getApplicationContext(), cal.getTimeInMillis(), cal1.getTimeInMillis(), ConnectivityManager.TYPE_WIFI, uid, resolveInfo.activityInfo.packageName,
                            resolveInfo.loadLabel(packageManager).toString(), resolveInfo.activityInfo.loadIcon(packageManager));
                }
                //Toast.makeText(context, "Service is still running", Toast.LENGTH_LONG).show();
                int maxId = findMaximumUsage(txSimple);
            int s = (int) (Double.parseDouble(txData.get(maxId).replaceAll("[^\\d.]", "")));
            Log.e("please",String.valueOf(data_get));
                try {
                    int checkoff = sharedPreferences.getInt("serviceget", 0);
                    if(checkoff == 1) {
                        if(Integer.valueOf(data_get)< s) {
                            NotificationHelper notificationHelper = new NotificationHelper(getApplicationContext());
                            notificationHelper.createNotification(applicationName.get(maxId) + " looks suspicious", "Transmitted " + txData.get(maxId), applicationIcon.get(maxId));
                        }
                        }
                } catch (Exception ex) {
                }
            return null;
        }


        @Override
        protected void onProgressUpdate(String... values) {
            notify();
        }


        @Override
        protected void onPostExecute(Void aVoid) {
            super.onPostExecute(aVoid);
        }

    }
}
